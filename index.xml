<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CielRouge</title>
    <link>https://cielrouge.github.io/</link>
    <description>Recent content on CielRouge</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 10 Nov 2018 10:56:27 +0800</lastBuildDate>
    
	<atom:link href="https://cielrouge.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Lyric: (羽生迷子)浮世巡り</title>
      <link>https://cielrouge.github.io/post/lyric-%E6%B5%AE%E4%B8%96%E5%B7%A1%E3%82%8A/</link>
      <pubDate>Sat, 10 Nov 2018 10:56:27 +0800</pubDate>
      
      <guid>https://cielrouge.github.io/post/lyric-%E6%B5%AE%E4%B8%96%E5%B7%A1%E3%82%8A/</guid>
      <description>現世巡り
常世の果て貴方に会いに
現世に還る
悲しみから連れ出すように
現世を巡る
背景、この世の皆様はおやすみ
これは孤児のお願い
さすらいの夢
浮世の街孤独を前に
現世に沈む
空蝉から逃げ出すように
現世を巡る
大抵この世のまやかしは泡沫
ならばまた次の夜へ
さすらいの夢
あの世の果て貴方に会いに
探し物はなんですか
遠い雲が手招くように
迎えがすぐそこに来てる
案外この世も悪ない
そうでしょう
さらば愛しのあの人
宴の始まり
ツキモノ
生まれながらに取り憑く化け物が
次第に大きくなった
気づいた時はもう手に負えなくて
身動きができなくなった
表に立てば拍手は止まね
人並の喜びを忘れた
俗世の化身になれたら
やり直すからいいさ
あと一つ二つ三つ目を望んだ貴方は今日も変えわらず
何も無い日々なら乾いてしまうと
足りない僕を蔑む
満たされぬ心に飲まれた阿保なら此の世もあの世も同じ
答えてよ人の子よ
足りない僕らの末路
忍ばざる者
器を見せて
忌み嫌われて
其れが何かは誰も知らない
かつて持っていた杯を壊して
また注いでも溢れる等身大
誰もいません
お帰りなさい
見ないでくれって嘘をついてた
俗世の化身になるまで
離れないでね
またね
永久の光に高みを望んだ貴方の正味は虚ろ
錆びついた日陰じゃ報われないから
燃えてる夜を彷徨う
絆された心に焼かれて朽ちれば誰かが見ていてくれた
明日から檻の中
死ねない僕らの末路
何かが欲しがるんだ
大人になるほどに
誰かに貰った愛など忘れるほどに
あと一つ二つ三つ目を望んだ貴方は今日も変えわらず
艶やかな嘘なら其れでもいいやと
足りない僕を咎めた
耳鳴りが止まない静かな夜なら言葉を紡いでみせろ
超えてゆけ修羅の道
乾いた僕らの末路
忍ばざる者
冥々
幽体離脱あまつさえ神頼み
愛の箱庭
語ってみたって届きやしない蟠り</description>
    </item>
    
    <item>
      <title>note-1017</title>
      <link>https://cielrouge.github.io/post/dnote-htt/</link>
      <pubDate>Wed, 17 Oct 2018 15:13:33 +0800</pubDate>
      
      <guid>https://cielrouge.github.io/post/dnote-htt/</guid>
      <description>dependent type over a type
$P$ be a dependent type over $A$, $Q$ be a dependent type over $P$
$Q(a,u)$ is a type for every $a:A$ and $u:P(a)$
a dependent type is a map of a type into a universe
dependent products
terms of $\prod (a:A), P(a)$ :=
sections of $P$ :=
functions from a term of $A$ to a term of type $P(a)$.
each judgement defines a term:
$a:A \vdash g(a):P(a)$ defines $\lambda a.</description>
    </item>
    
    <item>
      <title>2018-10-06</title>
      <link>https://cielrouge.github.io/post/181006/</link>
      <pubDate>Sat, 06 Oct 2018 23:19:48 +0800</pubDate>
      
      <guid>https://cielrouge.github.io/post/181006/</guid>
      <description>解答与问题之间有着空白断裂的工具索引与场景.
没有创造的读解，没有索引的工具，没有问题的解答，没有动机的优化.
时间的空白洗去记忆，而索引与作品留下了.
&amp;ldquo;the first is that we have not felt compelled to give the proofs of all the theorems. &amp;hellip; the second is that we have not always stated results in the maximum generality. &amp;hellip; the third is that we have hewed to the axiomatic foundations of the subject.&amp;rdquo;
2018-10-06</description>
    </item>
    
    <item>
      <title>Note: 同痕逐段线性逼近</title>
      <link>https://cielrouge.github.io/post/note-visualizingonemanifold/</link>
      <pubDate>Sun, 30 Sep 2018 18:27:05 +0800</pubDate>
      
      <guid>https://cielrouge.github.io/post/note-visualizingonemanifold/</guid>
      <description>Geometric Topology &amp;amp; Visualizing 1-Manifolds
环境同痕逼近, 几何对象在$R^3$中的嵌入的表示.
两个准则:
1. 逐段线性(PL)逼近，保持模型的拓扑
2. 动态变化中的拓扑保持
对参数1-流形的 曲率适应、拓扑保持 的逼近.
逐段线性(PL)逼近:
1. 拓扑等价于原来的流形
2. 最小化线性逼近的数量
3. 接受用户指定的距离与曲率的误差边界
Definition 1.
$X$, $Y$是$R^n$的子集. ambient isotopy 是一个连续函数 $H: R^n \times [0,1] \to R^n$ s.t.
1. $H(\cdot,0)$ 是identity函数
2. $H(X,1)=Y$
3. $\forall t \in [0,1]$, $H(\cdot, t)$ 是$R^3$上同胚。
参数1-流形的曲率和拓扑 记号: $c: [0,1]\to R^3$是$C^3$曲线，记
$$\mu_c([a,b]) = \int_a^b \parallel c&amp;rdquo;(t)\parallel dt$$
Theorem 1.
$c: [0,1]\to R^3$是$C^3$曲线. 对each $\epsilon &amp;gt; 0$, $\exists n \in \mathbb{N}$, $\exists$ partition $X = \lbrace p_1, &amp;hellip;, p_n \rbrace \subset [0,1]$ s.</description>
    </item>
    
    <item>
      <title>Note: 叶脉生成</title>
      <link>https://cielrouge.github.io/post/note-leafvenation/</link>
      <pubDate>Mon, 24 Sep 2018 16:17:02 +0800</pubDate>
      
      <guid>https://cielrouge.github.io/post/note-leafvenation/</guid>
      <description>Adam Runions, Martin Fuhrer, Brendan Lane, Pavol Federl, Anne−Gaëlle Rolland−Lagan, and Przemyslaw Prusinkiewicz. Modeling and visualization of leaf venation patterns. ACM Transactions on Graphics 24(3), pp. 702−711.
过程：1.叶脉向叶片的生长素源的发展. 2.根据与叶脉的近邻程度，调节生长素源分布. 3.根据叶片的生长，调节叶脉模式与源分布.
代表叶脉节点与生长素源的点集上，迭代几何运算.
保存一个叶脉连接图，以决定叶脉宽度.
生长的特征：growth tensor
极小曲面区域在各方向展开的量级，可能包含各区域的一个可能的旋转.
生长张量是 相对初等生长率(RERG) 的一般化.
RERG: 生长对象上$p$点处，线$l$的方向上测得的，极小距离随时间增长的速率.
此速率依据极小距离$\Delta s$正规化得:
$RERG_l(p) = (1/\Delta s)(d \Delta /dt)$
marginal: concentrated on the border
diffuse: spread throught the surface
isotropic: diffuse growth, expansion equal in all directions
uniform: growth tensor is the same at all points of the surface</description>
    </item>
    
    <item>
      <title>整理: Foldable,Traversable</title>
      <link>https://cielrouge.github.io/post/%E6%95%B4%E7%90%86foldtraverse/</link>
      <pubDate>Tue, 11 Sep 2018 13:07:50 +0800</pubDate>
      
      <guid>https://cielrouge.github.io/post/%E6%95%B4%E7%90%86foldtraverse/</guid>
      <description>Foldable data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a) instance Foldable Tree where foldMap f Empty = mempty foldMap f (Leaf x) = f x foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f rclass Foldable t where foldMap :: Monoid m =&amp;gt; (a -&amp;gt; m) -&amp;gt; t a -&amp;gt; m foldMap f = foldr (mappend .</description>
    </item>
    
    <item>
      <title>整理: State, Reader</title>
      <link>https://cielrouge.github.io/post/%E6%95%B4%E7%90%86state/</link>
      <pubDate>Mon, 10 Sep 2018 10:09:19 +0800</pubDate>
      
      <guid>https://cielrouge.github.io/post/%E6%95%B4%E7%90%86state/</guid>
      <description>State newtype State s a = State {runState :: s -&amp;gt; (a , s)} newtype (State s) a = State {runState :: s -&amp;gt; (a , s)} -- runState :: State s a -&amp;gt; s -&amp;gt; (a , s) -- State $ \s -&amp;gt; (a , s) = (State s) ainstance Functor (State s) where fmap f m = State $ \s -&amp;gt; case runState m s of (r , s) -&amp;gt; (f r , s)instance Applicative (State s) where pure x = State $ \s -&amp;gt; (x , s) m &amp;lt;*&amp;gt; n = State $ \s -&amp;gt; case runState m s of (f , s&amp;#39;) -&amp;gt; case runState n s&amp;#39; of (x , s&amp;#39;&amp;#39;) -&amp;gt; (f x , s&amp;#39;&amp;#39;) instance Monad (State s) where m &amp;gt;&amp;gt; n = State $ \s -&amp;gt; case runState m s of (r , s&amp;#39;) -&amp;gt; runState (n r) s&amp;#39; minimal complete definition:</description>
    </item>
    
    <item>
      <title>整理: Functor</title>
      <link>https://cielrouge.github.io/post/%E6%95%B4%E7%90%86functor/</link>
      <pubDate>Mon, 10 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://cielrouge.github.io/post/%E6%95%B4%E7%90%86functor/</guid>
      <description>map an element to an action.
元左乘 -&amp;gt; 一个自同态.
这样就好理解了.
Functor Functors: uniform action over a parameterized type
在「参数化的type」上的「一致action」
在「列表」上的「map函数」的一般化
Functor: 可被map-over的types的class
“对type 可被action做map 的形容”
fmap (f . g) == fmap f . fmap g
(&amp;lt;$&amp;gt;) -- fmap
(&amp;lt;&amp;amp;&amp;gt;) -- flip fmap
Applicative a functor with application
对type 可被 有sequential application的uniform action 做map 的形容
fmap f x = pure f &amp;lt;*&amp;gt; x
fmap f x = &amp;lt;*&amp;gt; (pure f) x</description>
    </item>
    
    <item>
      <title>untitled</title>
      <link>https://cielrouge.github.io/post/%E8%A1%A8%E7%A4%BA%E8%AE%BA%E7%AC%AC%E4%B8%80%E7%AB%A0/</link>
      <pubDate>Thu, 30 Aug 2018 10:47:24 +0800</pubDate>
      
      <guid>https://cielrouge.github.io/post/%E8%A1%A8%E7%A4%BA%E8%AE%BA%E7%AC%AC%E4%B8%80%E7%AB%A0/</guid>
      <description>$K$-代数: 环结构$A$, 交换环$K$到环结构中心$Z(A)$的环同态.
$M$是$A$-模 =&amp;gt; 有$K$-代数同态 $\lambda :A\to End_K (M)$.
给定$K$-代数同态$\nu: A\to End_K(M)$ =&amp;gt; $M$上有唯一$A$-模结构, 使$A\to End_K(M)$是$\nu$.
 对each $a\in A$, 定义$\underline{\lambda_a:M\to M}$, $\lambda_a:m\mapsto \mu (a,m) =: a\cdot m$. （由$A$是$K$-代数, $K\to Z(A)$, 证得$\lambda$的$K$-线性.）
对$\nu: A\to End_K(M)$, 定义$\mu:A\times M\to M$, $\mu (a,m):=\underline{\nu (a)(m)}$
 
一个表示是, 通过一个RealWorldObject上的作用, 一个抽象群的具体实现.
群在域上的一个$n$阶表示: $G \to GL_n(K)$
用 相同形状的可逆矩阵的 线性组合 形成 方阵；
用 群元的 $K$-线性组合 形成 $K$-代数.
(=&amp;gt; 群环的概念)
群环$RG$: copies of $R$ as $R$-modules, direct sum $\coprod_{g\in G} R$</description>
    </item>
    
  </channel>
</rss>